README Milestone 2 Texturing and Texture Animation:Implemented all of the requirements as listed on the course page:- A way to load images as textures into OpenGL for your world.- An addition to lambert.frag.glsl that makes use of a sampler2D to apply texture colors to a surface.- An alteration to lambert.frag.glsl to apply a Blinn-Phong specular reflection model with a cosine power that varies depending on block type.- An alteration to lambert.frag.glsl so that it includes a time variable as in Homework 5's OpenGL Fun, and uses this variable to animate the UVs on a LAVA block and WATER block. You may use a branching statement (i.e. IF statement) in your shader so that only LAVA and WATER are animated.- Enabling alpha blending in MyGL::initializeGL so that transparency can be applied to WATER blocks.- An additional interleaved VBO in the Chunk class in which you will store all non-opaque blocks (this is to handle how the OpenGL pipeline deals with transparency sorting).- An alteration to the VBO for the Chunk class, so that it additionally supports UV coordinates (vec2) and cosine power (float). You may also consider adding some sort of "animateable" flag to your VBO so that only triangles with the LAVA and WATER textures are animated in your shader.- Additional variables in the ShaderProgram class to support these texture features.Strategies:- I decided to have a helper method named getTexture in terrain.cpp, which allowed me to know what texture sample I should be using depending on the block type and face (since we need different texture samples for the top of a grass block versus the sides of a grass block, etc.). I used this information to get the top left corner of the texture sample in the createVertexPosNorUV method in terrain.cpp (which fills up the interleaved VBO’s for opaque and transparent blocks for chunks) and then got the other corner UV’s by simply adding/subtracting 1.0f / 16.0f from the x and y UV coordinates.- As said in the instructions, I created two separate VBO’s for chunks: one for opaque and one for transparent blocks. To handle their drawing separately, I created separate generate, bind and draw methods as well as separate index counters for opaque and transparent blocks in the shaderProgram and Drawable.- In order to animate the LAVA and WATER blocks, I used a uniform u_Time variable in the fragment shader. The way I implemented the animation is I keep incrementing the UV coordinates of the current pixel by one pixel (1.0f / 256.0f) along fs_UV.x to give the feeling of flow between the WATER and LAVA textures, and handle moving to the textures in the other row by bound check (whether the current fs_UV.x has exceeded 1)Troubles:- I’m not 100% sure if I implemented the Blinn Phong cosine power effect properly in my fragment shader since I’m not sure if I’m getting the desired shading effect. I’m using the formula from the lecture slides where I find the vector H (the mid vector between the view and light vectors) and dot it with the normal vector, but I might ask this to a TA at office hours just to make sure- I’m not sure if the transparency outcome is the desired one: I’m able to see the opaque blocks behind the transparent ones but I also think that some transparent blocks are not only containing the faces of neighboring opaque blocks, but also the faces of opaque blocks that are way under the transparent block I’m looking at. I will probably need to do some debugging on this- The animation of textures is slightly off at the very last transition. The way I increment fs_UV.x might be exceeding the bounds at the very end for a brief second, I will debug this after the presentation